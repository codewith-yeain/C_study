#include <stdio.h>

int main(void)
{
	// 관계 연산자와 논리 연산자
	int a = 30, b = 20, output;
	int res;

	res = (a > 10) && (a < 20);
	printf("(a > 10) && (a < 20) : %d\n", res);
	res = (a > 10) || (a < 20);
	printf("(a > 10) || (a < 20) : %d\n", res);
	res = !(a >= 30);
	printf("!(a >= 30) : %d\n", res);

	// 숏 서킷 룰(short circuit rule) : 좌항만으로 &&와 || 연산 결과를 판별하는 기능
	/*
	<장점: 불필요한 연산을 줄여줌>
	- &&는 좌항이 거짓이면 우항과 관계없이 결과는 거짓이므로 우항을 살펴 볼 필요가 없음
	- ||는 좌항이 참이면 우항과 관계없이 결과는 참이므로 우항을 살펴 볼 필요가 없음


	<단점>
	- 다만 숏 서킷 룰은 예상치 못한 결과를 만들 수 있으므로 주의할 필요가 있음
	- 만약 양수 a에 대하여 ++b 연산이 항상 실행되길 바랄 때 다음과 같은 식에서는 문제가 됨
	- ex) (a < 0) && (++b > 20) -> a가 0보다 크면 b 값은 증가되지 않기 때문
	*/

	//-----------------------------------------------------------------------------
	// 연산의 결과값을 사용하는 방법

	a + b; // 연산 결과 버려짐
	printf("%d + %d = %d", a, b, a + b); // 연산 결과를 바로 출력에 사용

	output = a + b; // 연산 결과를 변수에 저장
	printf("%d + %d = %d", a, b, output); // 저장된 값을 계속 사용


	// 연산을 하려면 메모리에 있는 a와 b의 값을 CPU의 저장 공간인 레지스터에 복사해야 함 (로드 load)
	// 데이터가 레지스터에 젖아되면 연산 장치인 ALU에 의해 덧셈 연산이 수행되고 그 결과값은 일단 레지스터에 저장됨
	// 이후 대입 연산을 수행하면 메모리 공간인 output에 복사되어 수식의 모든 과정이 완료됨(스토어 store)


	return 0;
}